#!/usr/bin/python

# python stuff
import time
import sys
import numpy as np

# index coding stuff
from Symbol import Symbol
from alignment import alignment, nullvec
from bs_index_coding import compute_interferers, transmit_messages, bs_decode_messages
from multirandperm import pairingperm

# tos stuff
from TxSerialMsg import *
from SymMsg import *
from tinyos.message import MoteIF

class Transmitter:
	def __init__(self, N, B=1, verbose=True, dest=False):
		self.verbose = verbose
		self.prevtime = time.time()
		self.N = N
		#self.A = make_A_matrix(self.N)
		self.counter = 0;
		self.num_transmissions = 0;
		self.current_row = 0;

		## Set up link to tos mote
		self.mif = MoteIF.MoteIF()
		self.source = self.mif.addSource("sf@localhost:9002")
		#TxSerialMsg.py is be generated by MIG class
		self.mif.addListener(self, TxSerialMsg)

		# generate random messages
		self.W = np.random.randint(0,2**16, (N,B)) # each message is an array of B uint16s

		# store final received messages. goal is to "de-NaN" by the end
		self.final_messages = np.nan*np.zeros((N, B))
		# keep track of all transmitted and received messages/symbols
		self.tx_symbols = np.array([]) # [1 -by- # of transmissions]

		# keep track of number of transmissions
		self.TOTAL_TRANSMISSIONS = 0

		# antidote matrix A
		self.A = np.diag(self.W.reshape(-1)) # receiver (row) i has access to the message it plans to send
		# Receiver i wants message dest[i]
		# e.g. dest = [1, 0] means R0 wants W[1] and R1 wants W[0]
		if dest == False:
			self.dest = pairingperm(N)
			if self.verbose:
				print 'Message destinations chosen by pairing'
				print 'dest:', self.dest
		else:
			self.dest = dest
		mat_dest = (np.arange(self.N), np.array(self.dest))
		signal_space = np.zeros((self.N,self.N))>0
		signal_space[mat_dest] = True;
		self.I = compute_interferers(self.A, signal_space)
		self.J = self.I.astype(float)
		self.J[mat_dest] = -1
		self.map = np.arange(self.N)
	
		if self.verbose:
			print 'Interferer matrix is:'
			print self.J

	def main_loop(self):
		eps_vec = .5*np.ones(self.N)
		i = 1
		while np.any(np.isnan(self.final_messages)):
			Kprime = len(self.map);
			if self.verbose:
				print 'Remaining ', Kprime, ' nodes are: '
				print self.map

			## special case for one remaining node
			if Kprime == 1:
				self.TOTAL_TRANSMISSIONS += 1
				while not transmit_messages(1, eps_vec[self.map]):
					self.TOTAL_TRANSMISSIONS += 1
				self.final_messages[self.map] = self.W[self.map]
			else:
				## Generate next m transmissions
				(V, U) = alignment('mixed', self.J, 1e-4, 100, False)
				m = np.shape(V)[0]
				if self.verbose:
					print 'Minimum rank is ', m

				# generate next symbol based on current V
				L = len(self.tx_symbols);
				if i == 1:
					L = 0

				unsolved = np.ones(Kprime) > 0
				m_i = 0
				while np.all(unsolved) and m_i < m:
					self.tx_symbols = np.append(self.tx_symbols, Symbol(V[m_i,:], self.W, self.map))
					R = transmit_messages(1, eps_vec[self.map])
					if i == 1:
						self.rx_symbols = R
					else:
						self.rx_symbols = np.bmat([self.rx_symbols, R])
					if self.verbose:
						print 'Transmission ', m_i+1, '/', m
						print self.rx_symbols.astype(int)
					self.TOTAL_TRANSMISSIONS += 1
					# solve for messages if possible
					#SEND TO TARGET HERE
					(unsolved, final_messages) = bs_decode_messages(self.dest, Kprime, self.map,
							self.rx_symbols, self.tx_symbols, self.A, self.I, self.J, self.W, self.final_messages, self.verbose)
					#RECEIVE FROM TARGET HERE
					#INTERPRET ACKS HERE
					m_i += 1
					i += 1
					self.final_messages = final_messages
				# update data structures
				self.map = np.nonzero(np.isnan(self.final_messages.reshape(-1)))[0]
				self.rx_symbols = self.rx_symbols[unsolved, :]
				self.J = self.J[unsolved, :]
				self.I = self.I[unsolved, :]
				self.A = self.A[unsolved, :]
		if self.verbose:
			print 'Total number of transmissions: ', self.TOTAL_TRANSMISSIONS
		return self.TOTAL_TRANSMISSIONS


	# Called by the MoteIF's receive thread when a new message
	# is received
	#def receive(self, src, msg):
		#time.sleep(1)
		#m = DecodedMsg(msg.dataGet())
		#self.counter = m.get_counter()
		#timeformat = '%Y/%d/%m %H:%M:%S'
		#print 'Received message %s: counter: %d' % (time.strftime(timeformat), self.counter)
		#print ' current row: ', m.get_current_row()
		#print ' true current row: ', self.current_row
		#z = np.array(m.get_V_row())
		#z = z[0:self.current_row+1]
		#print z
		#V = self.A[:m.get_current_row()+1]
		##U, S, W = np.linalg.svd(V.T)
		##print S
		#Vnull = V[ :, [1,3,5,7] ]
		##U,S,V = np.linalg.svd(Vnull.T)
		##print S
		#print np.matrix(Vnull).T*np.matrix(z).T
		
		##U, s, W = np.linalg.svd(Vnull.T)
		##print W.T

		##print self.A[m.get_current_row()][:]
		##print m.get_current_row()
		##print S
		##V_null = self.A[0:self.current_row+1,[1,3, 9, 14]]
		##U, S, W = np.linalg.svd(V_null)
		##print S
		##if m.get_perform_svd() == self.N:
			###print '  svd received:'
			##Svals = m.get_W()
			##print 'Rx svd: ', Svals
			##U,S,V = np.linalg.svd(self.A)
			###S = [s**2 for s in S]
			###print '  svd check:'
			##print 'PC svd: ', S
			##self.perform_svd = 0
			##self.A = make_A_matrix(self.N)
			##print 'MSE: ', np.linalg.norm(np.array(S)-np.array(Svals),2)
			##proctime = time.time() - self.prevtime
			##print 'Elapsed time: %f seconds' % proctime
		##else:
			##self.prevtime = time.time()
			##self.perform_svd += 1
		#self.counter += 1
		#self.current_row = (self.current_row + 1) % self.N
		##if self.current_row == 0:
			##self.A = make_A_matrix(self.N)
		#self.send()

	#uncomment this??
	def send(self):
		smsg = TxSerialMsg()
		#smsg.set_counter(self.counter)
		smsg.set_crow(self.current_row)
		smsg.set_V_row(self.A[self.current_row])
		smsg.set_data(self.sym[self.current_row])
		self.mif.sendMsg(self.source, 0xFFFF, smsg.get_amType(), 0, smsg)
		#TDMA round, send message j to mote self.dest[j]

#def make_A_matrix(N):
	#A = np.random.randn(N,N)
	#B = np.matrix(np.random.randn(4,4))
	#U, s, W = np.linalg.svd(B)
	#s[-1] = 0
	#B = np.array(U*np.diag(s)*W)
#
#	
	#A[0:4,1] = B[:,0]
	#A[0:4,3] = B[:,1]
	#A[0:4,5] = B[:,2]
	#A[0:4,7] = B[:,0]
	##print A
#
#
#
	#return A

if __name__ == "__main__":
	print "Running"
	np.set_printoptions(precision=3)
	np.set_printoptions(suppress=True)

	if len(sys.argv) > 1:
		N = int(sys.argv[1])
	else:
		N  = 6
	m = Transmitter(N, verbose=True)
	#m.tdma_stage()
	m.main_loop()
	time.sleep(1)
	#m.send()
