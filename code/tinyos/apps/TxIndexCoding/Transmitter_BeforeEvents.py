#!/usr/bin/python

# python stuff
import time
import sys
import numpy as np

# index coding stuff
from Symbol import Symbol
from alignment import alignment, nullvec
from bs_index_coding import compute_interferers, transmit_messages, bs_decode_messages
from multirandperm import pairingperm

# tos stuff, all needed?
from TxSerialMsg import *
from SymMsg import *
from T2HMsg import *
from AckMsg import *
from tinyos.message import MoteIF

class Transmitter:
	def __init__(self, N, B=1, verbose=True, dest=False): #is pieces 1 here?
		self.verbose = verbose
		self.prevtime = time.time()
		self.N = N
		#self.A = make_A_matrix(self.N)
		self.counter = 0;
		self.num_transmissions = 0;
		self.current_row = 0;

		## Set up link to tos mote
		self.mif = MoteIF.MoteIF()
		self.source = self.mif.addSource("sf@localhost:9002")
		#TxSerialMsg.py is be generated by MIG class
		self.mif.addListener(self, TxSerialMsg)

		# generate random messages
		self.W = np.random.randint(0,2**16, (N,B)) # each message is an array of B uint16s

		# store final received messages. goal is to "de-NaN" by the end
		self.final_messages = np.nan*np.zeros((N, B))
		# keep track of all transmitted and received messages/symbols
		self.tx_symbols = np.array([]) # [1 -by- # of transmissions]

		# keep track of number of transmissions
		self.TOTAL_TRANSMISSIONS = 0
		# for TDMA round also?
		self.TDMA_TRANSMISSIONS = 0

		# antidote matrix A
		self.A = np.diag(self.W.reshape(-1)) # receiver (row) i has access to the message it plans to send
		# Receiver i wants message dest[i]
		# e.g. dest = [1, 0] means R0 wants W[1] and R1 wants W[0]
		if dest == False:
			self.dest = pairingperm(N)
			if self.verbose:
				print 'Message destinations chosen by pairing'
				print 'dest:', self.dest
		else:
			self.dest = dest
		mat_dest = (np.arange(self.N), np.array(self.dest))
		signal_space = np.zeros((self.N,self.N))>0
		signal_space[mat_dest] = True;
		self.I = compute_interferers(self.A, signal_space)
		self.J = self.I.astype(float)
		self.J[mat_dest] = -1
		self.map = np.arange(self.N)
	
		if self.verbose:
			print 'Interferer matrix is:'
			print self.J

		#send the first tdma packet?

	def tdma_stage(self):
		smsg = TxSerialMsg()
		self.TDMA_MODE = 1;
		self.TDleft = np.arange(self.N, dtype=np.uint8)
		self.ackList = np.nan*self.TDleft
		#test to send something
		#smsg.set_messageid(1)
		#self.mif.sendMsg(self.source, 0xFFFF, smsg.get_amType(), 0, smsg)
		tm = 0;
		#set packet number
		while np.any(np.isnan(self.ackList)): #change while to if and call at the end of receive loop?
			tm = tm + 1
			for i in self.TDleft:
				#mote doesnt see any of these??
				self.TDMA_TRANSMISSIONS = self.TDMA_TRANSMISSIONS + 1
				#smsg.set_crow(255) #something to signal tdma mode, still necessary?
				smsg.set_messageid(int(i)) 
				#for(j=len(self.dest[i])) eventually loop through J matrix columns that are -1
				smsg.set_data(self.W[self.dest[i]])
				#also send own message w[i] for comparison????, set to V_row?
				smsg.set_V_row(self.W[i])
				smsg.set_current_transmission(self.TDMA_TRANSMISSIONS)
				self.mif.sendMsg(self.source, 0xFFFF, smsg.get_amType(), 0, smsg)
				time.sleep(.25) #.125 too fast?
				print'TDMA TRANSMISSION ', self.TDMA_TRANSMISSIONS, ': Motes remaining: ', self.TDleft
			##call tinyos receive thread instead?
			#rmsg = AckMsg(msg.dataGet())
			##check for acks, remove nodes with ack type 1 from TDMAleft, record transmissions?
			#newAck = rmsg.get_ACKs()
			#acklist[newAck==1] = 1
		print 'Finished TDMA after ', tm, ' transmissions.' #use tm or get_transmission from receive function? will it make a difference?

	
	
	def receive(self,src,msg):  #make this main_loop and have it call tdma_stage and index_stage?, or set different modes in the other functions
		#wait
		time.sleep(1)
		if self.TDMA_MODE:
			print 'RECEIVE FUNCTION (TDMA)'
			rmsg = T2HMsg(msg.dataGet())
			#check for acks, remove nodes with ack type 1 from TDMAleft, record transmissions?
			newAck = rmsg.get_ACKs()
			print 'Acks for transmission number ', rmsg.get_transmission(), ': ', newAck
			print 'Element equal to 1: ', np.array(newAck)==1 #want this to be an array of logicals
			#print self.ackList
			self.ackList[np.array(newAck)==1] = 1
			#self.ackList[3] = 1
			#print self.ackList
			self.TDleft = np.nonzero(np.isnan(self.ackList.reshape(-1)))[0] #seems to work
			#call tdma_stage(self) at end if np.any(np.isnan(self.ackList)) !
		else:
			print 'RECEIVE FUNCTION (INDEX CODING)'
			rmsgx = T2HMsg(msg.dataGet())
			#check for acks, remove nodes with ack type 1 from TDMAleft, record transmissions?
			newAck = rmsgx.get_ACKs()
			#print 'Acks for transmission number ', rmsgx.get_transmission(), ': ', newAck
			#RECEIVE FROM TARGET HERE
					##INTERPRET ACKS HERE
					#m_i += 1
					#i += 1
					#self.final_messages = final_messages
			# update data structures, and now final messages and unsolved
			#self.unsolved = np.array(newAck)!=1
			newAck2 = np.array(newAck)
			print 'RX ACKS: ' , newAck2
			self.unsolved2 = newAck2[self.map] != 1
			self.final_messages2 = self.final_messages
			self.final_messages2[newAck2==1] = 1
			#self.unsolved = self.final_messages != 1
			#print 'Rx DEST ', self.dest
			print 'Rx NEW UNSOLVED: ', self.unsolved2
			print 'Rx NEW finalmessages: ', self.final_messages2

			#self.map = np.nonzero(np.isnan(self.final_messages.reshape(-1)))[0]
			#self.rx_symbols = self.rx_symbols[self.unsolved, :]
			#self.J = self.J[self.unsolved, :]
			#self.I = self.I[self.unsolved, :]
			#self.A = self.A[self.unsolved, :]
			#call compute_matrices, send to all motes at end if np.any(np.isnan(self.final_messages)), or is it if np.all(self.unsolved) and m_i < m?? 

		
	

	def main_loop(self): #change to compute_matrixes
		smsgx = TxSerialMsg()
		self.TDMA_MODE = 0;
		eps_vec = .5*np.ones(self.N)
		i = 1
		while np.any(np.isnan(self.final_messages)):
			Kprime = len(self.map);
			if self.verbose:
				print 'Remaining ', Kprime, ' nodes are: '
				print self.map

			## special case for one remaining node
			if Kprime == 1:
				self.TOTAL_TRANSMISSIONS += 1
				while not transmit_messages(1, eps_vec[self.map]):
					self.TOTAL_TRANSMISSIONS += 1
				self.final_messages[self.map] = self.W[self.map]
			else:
				## Generate next m transmissions
				(V, U) = alignment('mixed', self.J, 1e-4, 100, False)
				m = np.shape(V)[0]
				if self.verbose:
					print 'Minimum rank is ', m

				# generate next symbol based on current V
				L = len(self.tx_symbols);
				if i == 1:
					L = 0

				self.unsolved = np.ones(Kprime) > 0
				m_i = 0
				while np.all(self.unsolved) and m_i < m:
					self.tx_symbols = np.append(self.tx_symbols, Symbol(V[m_i,:], self.W, self.map))
					R = transmit_messages(1, eps_vec[self.map])
					if i == 1:
						self.rx_symbols = R
					else:
						self.rx_symbols = np.bmat([self.rx_symbols, R])
					if self.verbose:
						print 'Transmission ', m_i+1, '/', m
						print self.rx_symbols.astype(int)
					self.TOTAL_TRANSMISSIONS += 1
					# solve for messages if possible
					(self.unsolved, final_messages) = bs_decode_messages(self.dest, Kprime, self.map,
							self.rx_symbols, self.tx_symbols, self.A, self.I, self.J, self.W, self.final_messages, self.verbose)
					time.sleep(.2)
					print 'UNSOLVED: ', self.unsolved
					print 'MAP: ' , self.map
					#SEND TO TARGET HERE, rewrite these lines
					#smsg.set_crow
					print 'tx map ', self.map
					smsgx.set_messageid(255)  #now something to represent index coding, 255?
					smsgx.set_data(np.dot(V[m_i],self.W,))					
					##also send own message w[i] for comparison????
					smsgx.set_V_row(V[m_i]) 
					smsgx.set_current_transmission(self.TOTAL_TRANSMISSIONS)
					self.mif.sendMsg(self.source, 0xFFFF, smsgx.get_amType(), 0, smsgx)
					#time.sleep(1) #.125 too fast?
	
					#INTERPRET ACKS IN RECEIVE FUNCTION
					m_i += 1
					i += 1
					self.final_messages = final_messages #still need final messages??
				# update data structures
				self.map = np.nonzero(np.isnan(self.final_messages.reshape(-1)))[0]
				self.rx_symbols = self.rx_symbols[self.unsolved, :]
				self.J = self.J[self.unsolved, :]
				self.I = self.I[self.unsolved, :]
				self.A = self.A[self.unsolved, :]
		if self.verbose:
			print 'Total number of transmissions: ', self.TOTAL_TRANSMISSIONS
		return self.TOTAL_TRANSMISSIONS


	# Called by the MoteIF's receive thread when a new message
	# is received
	#def receive(self, src, msg):
		#time.sleep(1)
		#m = DecodedMsg(msg.dataGet())
		#self.counter = m.get_counter()
		#timeformat = '%Y/%d/%m %H:%M:%S'
		#print 'Received message %s: counter: %d' % (time.strftime(timeformat), self.counter)
		#print ' current row: ', m.get_current_row()
		#print ' true current row: ', self.current_row
		#z = np.array(m.get_V_row())
		#z = z[0:self.current_row+1]
		#print z
		#V = self.A[:m.get_current_row()+1]
		##U, S, W = np.linalg.svd(V.T)
		##print S
		#Vnull = V[ :, [1,3,5,7] ]
		##U,S,V = np.linalg.svd(Vnull.T)
		##print S
		#print np.matrix(Vnull).T*np.matrix(z).T
		
		##U, s, W = np.linalg.svd(Vnull.T)
		##print W.T

		##print self.A[m.get_current_row()][:]
		##print m.get_current_row()
		##print S
		##V_null = self.A[0:self.current_row+1,[1,3, 9, 14]]
		##U, S, W = np.linalg.svd(V_null)
		##print S
		##if m.get_perform_svd() == self.N:
			###print '  svd received:'
			##Svals = m.get_W()
			##print 'Rx svd: ', Svals
			##U,S,V = np.linalg.svd(self.A)
			###S = [s**2 for s in S]
			###print '  svd check:'
			##print 'PC svd: ', S
			##self.perform_svd = 0
			##self.A = make_A_matrix(self.N)
			##print 'MSE: ', np.linalg.norm(np.array(S)-np.array(Svals),2)
			##proctime = time.time() - self.prevtime
			##print 'Elapsed time: %f seconds' % proctime
		##else:
			##self.prevtime = time.time()
			##self.perform_svd += 1
		#self.counter += 1
		#self.current_row = (self.current_row + 1) % self.N
		##if self.current_row == 0:
			##self.A = make_A_matrix(self.N)
		#self.send()

	#uncomment this?? is it still useful?
	def send(self,m_i):
		smsg = TxSerialMsg()
		#smsg.set_counter(self.counter)
		smsg.set_crow(self.current_row)
		#smsg.set_V_row(self.A[self.current_row])
		smsg.set_V_row(V[m_i,:])
		smsg.set_data(self.tx_symbols[:,m_i])
		Symbol(V[self.current_row,:], self.W, self.map)	  
		smsg.set_data(self.sym[self.current_row])
		self.mif.sendMsg(self.source, 0xFFFF, smsg.get_amType(), 0, smsg)
		#TDMA round, send message j to mote self.dest[j]


#def make_A_matrix(N):
	#A = np.random.randn(N,N)
	#B = np.matrix(np.random.randn(4,4))
	#U, s, W = np.linalg.svd(B)
	#s[-1] = 0
	#B = np.array(U*np.diag(s)*W)
#
#	
	#A[0:4,1] = B[:,0]
	#A[0:4,3] = B[:,1]
	#A[0:4,5] = B[:,2]
	#A[0:4,7] = B[:,0]
	##print A
#
#
#
	#return A

if __name__ == "__main__":
	print "Running"
	np.set_printoptions(precision=3)
	np.set_printoptions(suppress=True)

	if len(sys.argv) > 1:
		N = int(sys.argv[1])
	else:
		N  = 6
	m = Transmitter(N, verbose=True)
	m.tdma_stage()
	m.main_loop()
	time.sleep(1)
	#m.send()
