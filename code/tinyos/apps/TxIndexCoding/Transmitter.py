#!/usr/bin/python

# python stuff
import time
import sys
import numpy as np
import os.path 

# index coding stuff
from Symbol import Symbol
from alignment import alignment, nullvec
from bs_index_coding import compute_interferers, transmit_messages, bs_decode_messages
from multirandperm import pairingperm

# tos stuff, all needed?
from TxSerialMsg import *
from SymMsg import *
from T2HMsg import *
from AckMsg import *
from tinyos.message import MoteIF

class Transmitter:
	def __init__(self, N, logfile, itMax=1, B=1, verbose=True, dest=False): 
		#CHANGE SO THAT ONLY THINGS THAT ARE CALLED ONCE!!
		self.verbose = verbose
		self.prevtime = time.time()
		self.N = N
		self.logfile = logfile
		self.B = B
		self.itMax = itMax
		self.timeformat = '%Y/%d/%m %H:%M:%S'
		#self.A = make_A_matrix(self.N)
		#self.counter = 0;
		#self.num_transmissions = 0;
		self.current_row = 0; #needed now??
		Transmitter.setup_logfile(self)

		## Set up link to tos mote
		self.mif = MoteIF.MoteIF()
		self.source = self.mif.addSource("sf@localhost:9002")
		#TxSerialMsg.py is be generated by MIG class
		self.mif.addListener(self, TxSerialMsg)

		# RESET THESE
		## generate random messages
		#self.W = np.random.randint(0,2**16, (N,B)) # each message is an array of B uint16s
		##print 'W is :'
		##print self.W
		## store final received messages. goal is to "de-NaN" by the end
		##self.final_messages = np.nan*np.zeros((N, B))
		##not actually messages but indicator if all the pieces for the node have been received
		#self.final_messages = np.nan*np.zeros((N, 1))
		## keep track of all transmitted and received messages/symbols
		#self.tx_symbols = np.array([]) # [1 -by- # of transmissions]
#
		## keep track of number of transmissions
		#self.TOTAL_TRANSMISSIONS = 0
		## for TDMA round also?
		#self.TDMA_TRANSMISSIONS = 0

	   #antidote matrix A
		#self.A = np.diag(self.W.reshape(-1)) # receiver (row) i has access to the message it plans to send
		#rewrite so not dependent on W
		#self.A = np.eye(N)
		
		# Receiver i wants message dest[i]
		# e.g. dest = [1, 0] means R0 wants W[1] and R1 wants W[0]
		if dest == False:
			self.dest = pairingperm(N)
			if self.verbose:
				print 'Message destinations chosen by pairing'
				print 'dest:', self.dest
		else:
			self.dest = dest
		
		#rewrite A so not dependent on W
		
		self.it = 0
		Transmitter.reset(self)
		##RESET THESE
		#mat_dest = (np.arange(self.N), np.array(self.dest))
		#self.signal_space = np.zeros((self.N,self.N))>0
		#self.signal_space[mat_dest] = True;
		#self.A = np.eye(N)
		#self.I = compute_interferers(self.A, signal_space)
		#self.J = self.I.astype(float)
		#self.J[mat_dest] = -1
		#self.map = np.arange(self.N)
		#print 'size of I is ', np.size(self.I)
	#	
		#if self.verbose:
			#print 'Interferer matrix is:'
			#print self.J
#
		##RESET THESE
		#self.TDMA_MODE = 1;
		##self.tm = 0; #needed?
		#self.TDleft = np.arange(self.N, dtype=np.uint8)
		#self.ackList = np.nan*self.TDleft
		#self.ileft = 0; 
		##transmit the first message
		#Transmitter.tdma_stage(self)
		#self.ileft = 1

	
	def cleanup(self):
		#save to text file
		#epsString = [str(a) for a in self.epsVec]
		#epsString = '\t'.join([str(a) for a in list(self.epsVec[0])])
		epsString = '\t'.join(['%.3f' % a for a in list(self.epsVec[0])])
		#logstring = '%d\t%d\t%d\t%d\t%.5f\t%s' % (self.N, self.B, self.TDMA_TRANSMISSIONS, self.TOTAL_TRANSMISSIONS, self.epsIndex,self.epsVec) #print an array??
		#logstring = '%%d\t%d\t' % (self.TDMA_TRANSMISSIONS, self.TOTAL_TRANSMISSIONS)
		logstring = '%d\t%d\t%d\t%d\t%.5f\t%s' % (self.N, self.B, self.TDMA_TRANSMISSIONS, self.TOTAL_TRANSMISSIONS, self.epsIndex,epsString) #print an array??
		lf = open(self.logfile, 'a')
		lf.write(logstring)
		lf.write('\n')
		lf.close()


	def reset(self):
		self.it += 1
		#reinitialize for next experiment
		# generate random messages
		self.W = np.random.randint(0,2**16, (self.N,self.B)) # each message is an array of B uint16s
		#print 'W is :'
		#print self.W
		# store final received messages. goal is to "de-NaN" by the end
		#self.final_messages = np.nan*np.zeros((N, B))
		#not actually messages but indicator if all the pieces for the node have been received
		self.final_messages = np.nan*np.zeros((self.N, 1))
		# keep track of all transmitted and received messages/symbols
		self.tx_symbols = np.array([]) # [1 -by- # of transmissions]
	
		# keep track of number of transmissions
		self.TOTAL_TRANSMISSIONS = 0
		self.TDMA_TRANSMISSIONS = 0
		#make float so dont have to cast later
		self.TDMA_ERASURES = float(0)
		self.INDEX_ERASURES = float(0)
		self.TDMA_ERASURES_VEC = np.zeros((1,self.N),float)
		self.INDEX_ERASURES_VEC = np.zeros((1,self.N),float)
		self.epsIndex = float(0)
		self.epsVec = np.zeros((1,self.N),float)
		
		mat_dest = (np.arange(self.N), np.array(self.dest))
		signal_space = np.zeros((self.N,self.N))>0
		signal_space[mat_dest] = True;
		self.A = np.eye(self.N)
		self.I = compute_interferers(self.A, signal_space)
		self.J = self.I.astype(float)
		self.J[mat_dest] = -1
		self.map = np.arange(self.N)
		#print 'size of I is ', np.size(self.I)
		#only print once??	
		if self.verbose:
			print 'Interferer matrix is:'
			print self.J

		#return to tdma mode
		self.TDMA_MODE = 1;
		#self.tm = 0; #needed?
		self.TDleft = np.arange(self.N, dtype=np.uint8)
		self.ackList = np.nan*self.TDleft
		self.ileft = 0; 
		#transmit the first message
		Transmitter.tdma_stage(self)
		self.ileft = 1
	
	
	def tdma_stage(self):
		smsg = TxSerialMsg()
		#self.TDMA_MODE = 1;
		#self.TDleft = np.arange(self.N, dtype=np.uint8)
		#self.ackList = np.nan*self.TDleft
		#test to send something
		#smsg.set_messageid(1)
		#self.mif.sendMsg(self.source, 0xFFFF, smsg.get_amType(), 0, smsg)
		#tm = 0; #move up
		#set packet number
		#while np.any(np.isnan(self.ackList)): #change while to if and call at the end of receive loop?
			#tm = tm + 1
			#for i in self.TDleft:
				#mote doesnt see any of these??
		self.TDMA_TRANSMISSIONS += 1
		#smsg.set_crow(255) #something to signal tdma mode, still necessary?
		#smsg.set_messageid(int(self.ileft)) 
		smsg.set_messageid(int(self.TDleft[self.ileft])) 
		#for(j=len(self.dest[i])) eventually loop through J matrix columns that are -1
		#smsg.set_data(self.W[self.dest[self.ileft],:])
		smsg.set_data(self.W[self.dest[self.TDleft[self.ileft]],:])
		#also send own message w[i] for comparison????, set to V_row?
		#print 'TDMA V Row ', self.W
		#smsg.set_V_row(self.W[self.ileft])
		smsg.set_current_transmission(self.TDMA_TRANSMISSIONS)
		self.mif.sendMsg(self.source, 0xFFFF, smsg.get_amType(), 0, smsg)
		if self.verbose:
			print'TDMA TRANSMISSION ', self.TDMA_TRANSMISSIONS, ': Motes remaining: ', self.TDleft
		#print'Sending message to Mote ', int(self.TDleft[self.ileft])
			##call tinyos receive thread instead?
			#rmsg = AckMsg(msg.dataGet())
			##check for acks, remove nodes with ack type 1 from TDMAleft, record transmissions?
			#newAck = rmsg.get_ACKs()
			#acklist[newAck==1] = 1

	def index_stage(self):
		smsgx = TxSerialMsg()
		smsgx.set_messageid(255)  #now something to represent index coding, 255?
		#print 'V is ', self.V
		#print 'm_i is ', self.m_i
		#PIECES HERE? matrix multiply handles it
		#print 'mi: ', self.m_i
		#print 'map: ', self.map[self.m_i]
		smsgx.set_data(np.dot(self.V[self.m_i,:],self.W,))					
		#smsgx.set_data(np.dot(self.V[self.map[self.m_i],:],self.W,))					
		##also send own message w[i] for comparison????
		#smsgx.set_V_row(np.asarray(self.V[self.m_i], dtype=np.float32))
		#smsgx.set_V_row(np.array([1, 2, 3.5, 4.2, 5, 6, 7, 8], dtype=np.float64))
		#print 'sending row m of V: ', self.V[self.m_i]
		#smsgx.set_crow()
		
		smsgx.set_V_row(self.V[self.m_i,:])
		
		###random coding instead?
		#randomVrow = np.random.randn(1,self.N)
		###blah[0,abs(np.array(self.V[self.m_i]))<.0001] = 0
		###blah2 = np.asarray(blah,dtype="float64")
		###blah2 = np.asarray(blah)
		###print self.V[self.m_i,:], type(self.V[self.m_i,2])
		###print blah[0,:], type(blah[0,:])		
		#smsgx.set_V_row(randomVrow[0,:])

		##does not decode for random combinations, larger matrix needed to find a null vector????
		##smsgx.set_V_row(np.random.randn(1,self.N))
		
		smsgx.set_current_transmission(self.TOTAL_TRANSMISSIONS)
		self.mif.sendMsg(self.source, 0xFFFF, smsgx.get_amType(), 0, smsgx)
		if self.verbose:
				print 'Transmission ', self.m_i+1, '/', self.m  #m_i+1 or now just m_i ???
				#print self.rx_symbols.astype(int)
		self.m_i += 1
		self.i += 1


	
	def receive(self,src,msg):  #make this main_loop and have it call tdma_stage and index_stage?, or set different modes in the other functions
		#tdma tx, index tx, or completed depending on mode
		if self.TDMA_MODE==1:
			#print 'ileft is ', self.ileft, ', size if tdleft is  ', np.size(self.TDleft)
			##try moving this down??
			#if self.ileft == np.size(self.TDleft):
			##if self.ileft > np.size(self.TDleft):
				#self.ileft = 0; #only update acklist here?
				##not completely correct?? what if size changes inbetween?
				##only update tdleft here?
				#self.TDleft = np.nonzero(np.isnan(self.ackList.reshape(-1)))[0] 				

			print 'RECEIVE FUNCTION (TDMA)'
			rmsg = T2HMsg(msg.dataGet())
			#check for acks, remove nodes with ack type 1 from TDMAleft, record transmissions?
			newAck = rmsg.get_ACKs()
			print 'Acks for transmission number ', rmsg.get_transmission(), ': ', newAck #first one is 8? 2? garbage value	
			#print 'Element equal to 1: ', np.array(newAck)==1 #want this to be an array of logicals
			self.ackList[np.array(newAck)==1] = 1
			self.TDMA_ERASURES += np.sum(np.array(newAck)==2)
			self.TDMA_ERASURES_VEC += np.array(newAck)==2
			#print 'number of erasures ', self.TDMA_ERASURES
			#print 'Erasure vector:', self.TDMA_ERASURES_VEC
			#self.TDleft = np.nonzero(np.isnan(self.ackList.reshape(-1)))[0]
			#call tdma_stage(self) at end if np.any(np.isnan(self.ackList))
			
			#try moving this here??
			if self.ileft == np.size(self.TDleft):
			#if self.ileft > np.size(self.TDleft):
				self.ileft = 0; #only update acklist here?
				#not completely correct?? what if size changes inbetween?
				#only update tdleft here?
				self.TDleft = np.nonzero(np.isnan(self.ackList.reshape(-1)))[0] 				
			
			#if not done, transmit next
			if np.any(np.isnan(self.ackList)):
				#self.tm = self.tm + 1
				#for i in self.TDleft:
				Transmitter.tdma_stage(self)
				self.ileft += 1
				
			else:
				print 'Finished TDMA after', self.TDMA_TRANSMISSIONS, 'transmissions and', self.TDMA_ERASURES, 'erasures. Current erasure probability is', self.TDMA_ERASURES/(self.N*self.TDMA_TRANSMISSIONS) #use get_transmission from receive function? will it make a difference?
				print 'EpsVec (TDMA only):', self.TDMA_ERASURES_VEC/self.TDMA_TRANSMISSIONS
				#COMPUTE ATTEMPTS PER NODE?? dont need if broadcasting every transmission
				self.TDMA_MODE = 0; #initialize and proceed to index coding mode
				self.m_i = 0;
				self.i = 1;
				self.m = 0;
				self.unsolved = self.map > -50; #array of true the size of self.map 
				self.rx_symbols = 0;
				self.eps_vec = 0*np.ones(self.N)
				R = transmit_messages(1, self.eps_vec[self.map])
				self.rx_symbols = R
				#self.INDEX_ERASURES = 0;
				#send the first index message here? call compute_matrices for the first time here?
				#handle first case here?
	
		elif self.TDMA_MODE == 0:
			print 'RECEIVE FUNCTION (INDEX CODING)'
			#get next set of messages
			#if self.m_i == m or self.i == 0:
			#update data structures and map (next unsolved vector) once the round has been completed
			#if self.m_i == self.m or np.any(~self.unsolved):
				#self.m_i = 0;
			if self.TOTAL_TRANSMISSIONS == 0:
				self.map = np.nonzero(np.isnan(self.final_messages.reshape(-1)))[0]
				self.rx_symbols = self.rx_symbols[self.unsolved, :]
				self.J = self.J[self.unsolved, :]
				self.I = self.I[self.unsolved, :]
				self.A = self.A[self.unsolved, :]
				Transmitter.compute_matrices(self)
				#time.sleep(3)
				#case for first transmission, must compute matrices first?
				self.TOTAL_TRANSMISSIONS = 1
				Transmitter.index_stage(self)
				#self.m_i += 1
				#self.i += 1
				return
			
			
			#if self.m_i == self.m or np.any(~self.unsolved):
				##Transmitter.compute_matrices(self)
				#self.map = np.nonzero(np.isnan(self.final_messages.reshape(-1)))[0]
				#self.rx_symbols = self.rx_symbols[self.unsolved, :]
				#self.J = self.J[self.unsolved, :]
				#self.I = self.I[self.unsolved, :]
				#self.A = self.A[self.unsolved, :]
				#Transmitter.compute_matrices(self)			
			##case for first transmission, must compute matrices first?
			#if self.TOTAL_TRANSMISSIONS == 0:
				#self.TOTAL_TRANSMISSIONS = 1
				#Transmitter.index_stage(self)
				#self.m_i += 1
				#self.i += 1
				#return
#	
			
			rmsgx = T2HMsg(msg.dataGet())
			#check for acks, remove nodes with ack type 1 from TDMAleft, record transmissions?
			newAck = np.array(rmsgx.get_ACKs())
			#print 'Acks for transmission number ', rmsgx.get_transmission(), ': ', newAck
			print 'RX ACKS: ' , newAck
			print 'Remaining nodes: ', self.map
			self.unsolved = newAck[self.map] != 1
			#self.final_messages2 = self.final_messages
			self.final_messages[newAck==1] = 1
			#CALCULATE ERASURES FROM THE NUMBER OF 2S, all 2s are useful, even if exited system becaus ergotic etc
			#calculate for each node?
			#print 'index erasures (old):', self.INDEX_ERASURES_VEC
			self.INDEX_ERASURES += np.sum(newAck==2)
			self.INDEX_ERASURES_VEC += newAck==2
			print 'Erasure Vector (index):', self.INDEX_ERASURES_VEC
			#self.unsolved = self.final_messages != 1
			#print 'Rx DEST ', self.dest
			#print 'Rx NEW UNSOLVED: ', self.unsolved
			#print 'Rx NEW finalmessages: '
			#print self.final_messages
			
			if self.m_i == self.m or np.any(~self.unsolved):
				#Transmitter.compute_matrices(self)
				self.m_i = 0;
				self.map = np.nonzero(np.isnan(self.final_messages.reshape(-1)))[0]
				self.rx_symbols = self.rx_symbols[self.unsolved, :]
				self.J = self.J[self.unsolved, :]
				self.I = self.I[self.unsolved, :]
				self.A = self.A[self.unsolved, :]
				Transmitter.compute_matrices(self)
				#time.sleep(3)

			
			#send to all motes at end if np.any(np.isnan(self.final_messages)) ?? 
			if np.any(np.isnan(self.final_messages)):
				#print 'm_i' ,self.m_i
				self.tx_symbols = np.append(self.tx_symbols, Symbol(self.V[self.m_i,:], self.W, self.map))
				R = transmit_messages(1, self.eps_vec[self.map])
				if self.i == 1:
					self.rx_symbols = R
				else:
					self.rx_symbols = np.bmat([self.rx_symbols, R])
				#if self.verbose:
					#print 'Transmission ', self.m_i+1, '/', self.m  #m_i+1 or now just m_i ???
					#print self.rx_symbols.astype(int)
				self.TOTAL_TRANSMISSIONS += 1
				Transmitter.index_stage(self)
				#self.m_i += 1
				#self.i += 1
				#Transmitter.compute_matrices(self)
				#print 'late unsolved is ', self.unsolved
			else:
				#compute overall erasure probabilities for the iteration
				#self.epsIndex = float(self.INDEX_ERASURES)/float(self.N*self.TOTAL_TRANSMISSIONS)
				#now both tdma and index
				self.epsIndex = (self.INDEX_ERASURES+self.TDMA_ERASURES)/(self.N*(self.TOTAL_TRANSMISSIONS+self.TDMA_TRANSMISSIONS))
				self.epsVec = (self.TDMA_ERASURES_VEC+self.INDEX_ERASURES_VEC)/(self.TDMA_TRANSMISSIONS+self.TOTAL_TRANSMISSIONS)
				if self.verbose:
					print 'ITERATION', self.it, ', INDEX CODING TRANSMISSIONS:', self.TOTAL_TRANSMISSIONS
					print 'ERASURES:', self.INDEX_ERASURES, ', EPS:', self.epsIndex, 'EPS (index only):', self.INDEX_ERASURES/(self.N*self.TOTAL_TRANSMISSIONS)
					print 'EpsVec:', self.epsVec 
					#write epsvec instead
				#COMPUTE ATTEMPTS PER NODE?
				#self.TDMA_MODE = -1
				#call cleanup and reset functions!!!!!
				Transmitter.cleanup(self)
				if (self.it < self.itMax):
					Transmitter.reset(self)
				else:
					self.TDMA_MODE = -1
				return self.TOTAL_TRANSMISSIONS #also exit program?
		else:
			#completed, print this indefinitely
			#print 'INDEX CODING COMPLETE: Total number of transmissions: ', self.TOTAL_TRANSMISSIONS
			print self.it, 'ITERATIONS COMPLETE'
			return self.TOTAL_TRANSMISSIONS
			#iterate??
		

	def compute_matrices(self): #change to compute_matrixes
		#self.TDMA_MODE = 0;
		#eps_vec = .5*np.ones(self.N)
		self.eps_vec = 0*np.ones(self.N)
		#self.i = 1
		#while np.any(np.isnan(self.final_messages)):
		Kprime = len(self.map);
		if self.verbose:
			print 'Remaining ', Kprime, ' nodes are: '
			print self.map
			## special case for one remaining node
			#doesnt make sense anymore, must change
		if Kprime == 1:
		#smsgx.set_V_row(self.V[self.m_i,:])
			#self.TOTAL_TRANSMISSIONS += 1
			#while not transmit_messages(1, self.eps_vec[self.map]):
				#self.TOTAL_TRANSMISSIONS += 1
			#print 'map is ', self.map
			#print 'W is ', self.W
			#print 'final messages are', self.final_messages
			#self.final_messages[self.map] = self.W[self.map]
			#make a new V to transmit instead, just what W needs
			self.V = np.zeros((1,self.N))
			self.V[0,self.map] = 1
			self.m = 1
		else:
			## Generate next m transmissions
			#(self.V, U) = alignment('mixed', self.J, 1e-4, 100, True)
			(self.V, U) = alignment('greedy', self.J, 1e-4, 100, False)
			#try changing it here??
			self.V = np.asarray(self.V)
			#RANDOM INSTEAD??? even easier, change right before transmission!
			#self.V = np.random.
			print 'new V is '
			print self.V
			#print 'type of new V is ', type(self.V)
			#print 'type of an element of new V is ', type(self.V[0,0])
			self.m = np.shape(self.V)[0]
			if self.verbose:
				print 'Minimum rank is ', self.m
			# generate next symbol based on current V
			L = len(self.tx_symbols);
			if self.i == 1:
				L = 0
			self.unsolved = np.ones(Kprime) > 0
			##print S
			#Vnull = V[ :, [1,3,5,7] ]
			##U,S,V = np.linalg.svd(Vnull.T)


	def setup_logfile(self):
		if not os.path.isfile(self.logfile):
			lf = open(self.logfile,'w')
			lf.write('Index Coding (Basic Antidotes) Log File\n')
			#ADD TIME
			#lf.write('%s\nN = %d\nPIECES = %d\n\n' % (time.strftime(self.timeformat), self.N, self.B))
			lf.write('%s\n\n' % time.strftime(self.timeformat))
			lf.write('N\tPIECES\tnumTDMA\tnumIndex\tepsAvg\tepsVec\n')  #what else, time that started, erasures, slot time somehow?
			#add individual erasures?
			#lf.write('TDMA Transmissions\t Index Transmissions\n')  #what else, time that started, erasures, slot time somehow?
			lf.close()

if __name__ == "__main__":
	print "Running"
	np.set_printoptions(precision=3)
	np.set_printoptions(suppress=True)

	if len(sys.argv) > 1:
		N = int(sys.argv[1])
	else:
		N  = 8
	#if len(sys.argv) > 1
		#expMax = int(sys.argv

	#iterate here?? for loop?
	
	m = Transmitter(N, logfile='log01_28_2012.txt', itMax=100, B=4, verbose=True)
	#iterate here???
	#while (m.TDMA_MODE != -1):
		#time.sleep(.5)
	
	#tot = m.TOTAL_TRANSMISSIONS
	#print 'TDMA MODE is ', m.TDMA_MODE, '. Total for this experiment is ', tot
	
	##better way to iterate? will a loop work if each m is destroyed after it is done, something like constructor/destructor???
	#del m  #would this work? STILL PRINTS BOTH!!!

	#m = Transmitter(N, B=2, verbose=True)
	##iterate here???
	#while (m.TDMA_MODE != -1):
		#time.sleep(.5)
	
	#tot = m.TOTAL_TRANSMISSIONS
	#print 'TDMA MODE is ', m.TDMA_MODE, '. Total for this experiment is ', tot

	#m.compute_matrices()
	#m.tdma_stage()
	#m.main_loop()
	#time.sleep(1)
	#m.send()

