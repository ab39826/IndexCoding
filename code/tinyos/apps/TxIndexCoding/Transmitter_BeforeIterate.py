#!/usr/bin/python

# python stuff
import time
import sys
import numpy as np

# index coding stuff
from Symbol import Symbol
from alignment import alignment, nullvec
from bs_index_coding import compute_interferers, transmit_messages, bs_decode_messages
from multirandperm import pairingperm

# tos stuff, all needed?
from TxSerialMsg import *
from SymMsg import *
from T2HMsg import *
from AckMsg import *
from tinyos.message import MoteIF

class Transmitter:
	def __init__(self, N, B=1, verbose=True, dest=False): #is pieces 1 here?
		#CHANGE SO THAT ONLY THINGS THAT ARE CALLED ONCE!!
		self.verbose = verbose
		self.prevtime = time.time()
		self.N = N
		#self.A = make_A_matrix(self.N)
		self.counter = 0;
		self.num_transmissions = 0;
		self.current_row = 0;

		## Set up link to tos mote
		self.mif = MoteIF.MoteIF()
		self.source = self.mif.addSource("sf@localhost:9002")
		#TxSerialMsg.py is be generated by MIG class
		self.mif.addListener(self, TxSerialMsg)

		# generate random messages
		self.W = np.random.randint(0,2**16, (N,B)) # each message is an array of B uint16s
		#print 'W is :'
		#print self.W
		# store final received messages. goal is to "de-NaN" by the end
		self.final_messages = np.nan*np.zeros((N, B))
		#not actually messages but indicator if all the pieces for the node have been received
		self.final_messages = np.nan*np.zeros((N, 1))
		# keep track of all transmitted and received messages/symbols
		self.tx_symbols = np.array([]) # [1 -by- # of transmissions]

		# keep track of number of transmissions
		self.TOTAL_TRANSMISSIONS = 0
		# for TDMA round also?
		self.TDMA_TRANSMISSIONS = 0

		# antidote matrix A
		#self.A = np.diag(self.W.reshape(-1)) # receiver (row) i has access to the message it plans to send
		#rewrite so not dependent on W
		self.A = np.eye(N)
		
		# Receiver i wants message dest[i]
		# e.g. dest = [1, 0] means R0 wants W[1] and R1 wants W[0]
		if dest == False:
			self.dest = pairingperm(N)
			if self.verbose:
				print 'Message destinations chosen by pairing'
				print 'dest:', self.dest
		else:
			self.dest = dest
		mat_dest = (np.arange(self.N), np.array(self.dest))
		signal_space = np.zeros((self.N,self.N))>0
		signal_space[mat_dest] = True;
		#rewrite A so not dependent on W
		self.A = np.eye(N)
		self.I = compute_interferers(self.A, signal_space)
		self.J = self.I.astype(float)
		self.J[mat_dest] = -1
		self.map = np.arange(self.N)
		print 'size of I is ', np.size(self.I)
	
		if self.verbose:
			print 'Interferer matrix is:'
			print self.J

		self.TDMA_MODE = 1;
		#self.tm = 0; #needed?
		self.TDleft = np.arange(self.N, dtype=np.uint8)
		self.ackList = np.nan*self.TDleft
		self.ileft = 0; 
		#transmit the first message
		Transmitter.tdma_stage(self)
		self.ileft = 1

	def tdma_stage(self):
		smsg = TxSerialMsg()
		#self.TDMA_MODE = 1;
		#self.TDleft = np.arange(self.N, dtype=np.uint8)
		#self.ackList = np.nan*self.TDleft
		#test to send something
		#smsg.set_messageid(1)
		#self.mif.sendMsg(self.source, 0xFFFF, smsg.get_amType(), 0, smsg)
		#tm = 0; #move up
		#set packet number
		#while np.any(np.isnan(self.ackList)): #change while to if and call at the end of receive loop?
			#tm = tm + 1
			#for i in self.TDleft:
				#mote doesnt see any of these??
		self.TDMA_TRANSMISSIONS += 1
		#smsg.set_crow(255) #something to signal tdma mode, still necessary?
		#smsg.set_messageid(int(self.ileft)) 
		smsg.set_messageid(int(self.TDleft[self.ileft])) 
		#for(j=len(self.dest[i])) eventually loop through J matrix columns that are -1
		#smsg.set_data(self.W[self.dest[self.ileft],:])
		smsg.set_data(self.W[self.dest[self.TDleft[self.ileft]],:])
		#also send own message w[i] for comparison????, set to V_row?
		#print 'TDMA V Row ', self.W
		#smsg.set_V_row(self.W[self.ileft])
		smsg.set_current_transmission(self.TDMA_TRANSMISSIONS)
		self.mif.sendMsg(self.source, 0xFFFF, smsg.get_amType(), 0, smsg)
		if self.verbose:
			print'TDMA TRANSMISSION ', self.TDMA_TRANSMISSIONS, ': Motes remaining: ', self.TDleft
		#print'Sending message to Mote ', int(self.TDleft[self.ileft])
			##call tinyos receive thread instead?
			#rmsg = AckMsg(msg.dataGet())
			##check for acks, remove nodes with ack type 1 from TDMAleft, record transmissions?
			#newAck = rmsg.get_ACKs()
			#acklist[newAck==1] = 1

	def index_stage(self):
		smsgx = TxSerialMsg()
		smsgx.set_messageid(255)  #now something to represent index coding, 255?
		#print 'V is ', self.V
		#print 'm_i is ', self.m_i
		#PIECES HERE? matrix multiply handles it
		smsgx.set_data(np.dot(self.V[self.m_i,:],self.W,))					
		##also send own message w[i] for comparison????
		#smsgx.set_V_row(np.asarray(self.V[self.m_i], dtype=np.float32))
		#smsgx.set_V_row(np.array([1, 2, 3.5, 4.2, 5, 6, 7, 8], dtype=np.float64))
		#print 'sending row m of V: ', self.V[self.m_i]
		smsgx.set_V_row(self.V[self.m_i,:])
		smsgx.set_current_transmission(self.TOTAL_TRANSMISSIONS)
		self.mif.sendMsg(self.source, 0xFFFF, smsgx.get_amType(), 0, smsgx)
		if self.verbose:
				print 'Transmission ', self.m_i+1, '/', self.m  #m_i+1 or now just m_i ???
				#print self.rx_symbols.astype(int)
		self.m_i += 1
		self.i += 1


	
	def receive(self,src,msg):  #make this main_loop and have it call tdma_stage and index_stage?, or set different modes in the other functions
		#tdma tx, index tx, or completed depending on mode
		if self.TDMA_MODE==1:
			#print 'ileft is ', self.ileft, ', size if tdleft is  ', np.size(self.TDleft)
			if self.ileft == np.size(self.TDleft):
				self.ileft = 0; #only update acklist here?
				#not completely correct?? what if size changes inbetween?
				#only update tdleft here?
				self.TDleft = np.nonzero(np.isnan(self.ackList.reshape(-1)))[0] 				
			print 'RECEIVE FUNCTION (TDMA)'
			rmsg = T2HMsg(msg.dataGet())
			#check for acks, remove nodes with ack type 1 from TDMAleft, record transmissions?
			newAck = rmsg.get_ACKs()
			print 'Acks for transmission number ', rmsg.get_transmission(), ': ', newAck #first one is 8? 2? garbage value
			#print 'Element equal to 1: ', np.array(newAck)==1 #want this to be an array of logicals
			self.ackList[np.array(newAck)==1] = 1
			#self.TDleft = np.nonzero(np.isnan(self.ackList.reshape(-1)))[0]
			#call tdma_stage(self) at end if np.any(np.isnan(self.ackList))
			if np.any(np.isnan(self.ackList)):
				#self.tm = self.tm + 1
				#for i in self.TDleft:
				Transmitter.tdma_stage(self)
				self.ileft += 1
				
			else:
				print 'Finished TDMA after ', self.TDMA_TRANSMISSIONS, ' transmissions.' #use get_transmission from receive function? will it make a difference?
				#COMPUTE ATTEMPTS PER NODE??
				self.TDMA_MODE = 0; #initialize and proceed to index coding mode
				self.m_i = 0;
				self.i = 1;
				self.m = 0;
				self.unsolved = self.map > -50; #array of true the size of self.map 
				self.rx_symbols = 0;
				self.eps_vec = 0*np.ones(self.N)
				R = transmit_messages(1, self.eps_vec[self.map])
				self.rx_symbols = R
				#send the first index message here? call compute_matrices for the first time here?
				#handle first case here?
	
		elif self.TDMA_MODE == 0:
			print 'RECEIVE FUNCTION (INDEX CODING)'
			#get next set of messages
			#if self.m_i == m or self.i == 0:
			#update data structures and map (next unsolved vector) once the round has been completed
			#if self.m_i == self.m or np.any(~self.unsolved):
				#self.m_i = 0;
			if self.TOTAL_TRANSMISSIONS == 0:
				self.map = np.nonzero(np.isnan(self.final_messages.reshape(-1)))[0]
				self.rx_symbols = self.rx_symbols[self.unsolved, :]
				self.J = self.J[self.unsolved, :]
				self.I = self.I[self.unsolved, :]
				self.A = self.A[self.unsolved, :]
				Transmitter.compute_matrices(self)			
				#case for first transmission, must compute matrices first?
				self.TOTAL_TRANSMISSIONS = 1
				Transmitter.index_stage(self)
				#self.m_i += 1
				#self.i += 1
				return
			
			
			#if self.m_i == self.m or np.any(~self.unsolved):
				##Transmitter.compute_matrices(self)
				#self.map = np.nonzero(np.isnan(self.final_messages.reshape(-1)))[0]
				#self.rx_symbols = self.rx_symbols[self.unsolved, :]
				#self.J = self.J[self.unsolved, :]
				#self.I = self.I[self.unsolved, :]
				#self.A = self.A[self.unsolved, :]
				#Transmitter.compute_matrices(self)			
			##case for first transmission, must compute matrices first?
			#if self.TOTAL_TRANSMISSIONS == 0:
				#self.TOTAL_TRANSMISSIONS = 1
				#Transmitter.index_stage(self)
				#self.m_i += 1
				#self.i += 1
				#return
#	
			
			rmsgx = T2HMsg(msg.dataGet())
			#check for acks, remove nodes with ack type 1 from TDMAleft, record transmissions?
			newAck = np.array(rmsgx.get_ACKs())
			#print 'Acks for transmission number ', rmsgx.get_transmission(), ': ', newAck
			print 'RX ACKS: ' , newAck
			print 'Remaining nodes: ', self.map
			self.unsolved = newAck[self.map] != 1
			#self.final_messages2 = self.final_messages
			self.final_messages[newAck==1] = 1
			#self.unsolved = self.final_messages != 1
			#print 'Rx DEST ', self.dest
			#print 'Rx NEW UNSOLVED: ', self.unsolved
			#print 'Rx NEW finalmessages: '
			#print self.final_messages
			
			if self.m_i == self.m or np.any(~self.unsolved):
				#Transmitter.compute_matrices(self)
				self.m_i = 0;
				self.map = np.nonzero(np.isnan(self.final_messages.reshape(-1)))[0]
				self.rx_symbols = self.rx_symbols[self.unsolved, :]
				self.J = self.J[self.unsolved, :]
				self.I = self.I[self.unsolved, :]
				self.A = self.A[self.unsolved, :]
				Transmitter.compute_matrices(self)			
			
			#send to all motes at end if np.any(np.isnan(self.final_messages)) ?? 
			if np.any(np.isnan(self.final_messages)):
				#print 'm_i' ,self.m_i
				self.tx_symbols = np.append(self.tx_symbols, Symbol(self.V[self.m_i,:], self.W, self.map))
				R = transmit_messages(1, self.eps_vec[self.map])
				if self.i == 1:
					self.rx_symbols = R
				else:
					self.rx_symbols = np.bmat([self.rx_symbols, R])
				#if self.verbose:
					#print 'Transmission ', self.m_i+1, '/', self.m  #m_i+1 or now just m_i ???
					#print self.rx_symbols.astype(int)
				self.TOTAL_TRANSMISSIONS += 1
				Transmitter.index_stage(self)
				#self.m_i += 1
				#self.i += 1
				#Transmitter.compute_matrices(self)
				#print 'late unsolved is ', self.unsolved
			else:
				if self.verbose:
					print 'Total number of transmissions: ', self.TOTAL_TRANSMISSIONS
				#COMPUTE ATTEMPTS PER NODE?
				self.TDMA_MODE = -1
				#call cleanup and reset functions!!!!!
				return self.TOTAL_TRANSMISSIONS #also exit program?
		else:
			#completed, print this indefinitely
			print 'INDEX CODING COMPLETE: Total number of transmissions: ', self.TOTAL_TRANSMISSIONS
			return self.TOTAL_TRANSMISSIONS
			#iterate??
		

	def compute_matrices(self): #change to compute_matrixes
		#self.TDMA_MODE = 0;
		#eps_vec = .5*np.ones(self.N)
		self.eps_vec = 0*np.ones(self.N)
		#self.i = 1
		#while np.any(np.isnan(self.final_messages)):
		Kprime = len(self.map);
		if self.verbose:
			print 'Remaining ', Kprime, ' nodes are: '
			print self.map
			## special case for one remaining node
			#doesnt make sense anymore, must change
		if Kprime == 1:
			#self.TOTAL_TRANSMISSIONS += 1
			#while not transmit_messages(1, self.eps_vec[self.map]):
				#self.TOTAL_TRANSMISSIONS += 1
			#print 'map is ', self.map
			#print 'W is ', self.W
			#print 'final messages are', self.final_messages
			#self.final_messages[self.map] = self.W[self.map]
			#make a new V to transmit instead, just what W needs
			self.V = np.zeros((1,self.N))
			self.V[0,self.map] = 1
			self.m = 1
		else:
			## Generate next m transmissions
			(self.V, U) = alignment('mixed', self.J, 1e-4, 100, False)
			#try changing it here??
			self.V = np.asarray(self.V)
			print 'new V is '
			print self.V
			#print 'type of new V is ', type(self.V)
			#print 'type of an element of new V is ', type(self.V[0,0])
			self.m = np.shape(self.V)[0]
			if self.verbose:
				print 'Minimum rank is ', self.m
			# generate next symbol based on current V
			L = len(self.tx_symbols);
			if self.i == 1:
				L = 0
			self.unsolved = np.ones(Kprime) > 0
			##print S
			#Vnull = V[ :, [1,3,5,7] ]
			##U,S,V = np.linalg.svd(Vnull.T)



if __name__ == "__main__":
	print "Running"
	np.set_printoptions(precision=3)
	np.set_printoptions(suppress=True)

	if len(sys.argv) > 1:
		N = int(sys.argv[1])
	else:
		N  = 6
	
	#iterate here?? for loop?
	
	m = Transmitter(N, B=2, verbose=True)
	#iterate here???
	#while (m.TDMA_MODE != -1):
		#time.sleep(.5)
	
	#tot = m.TOTAL_TRANSMISSIONS
	#print 'TDMA MODE is ', m.TDMA_MODE, '. Total for this experiment is ', tot
	
	##better way to iterate? will a loop work if each m is destroyed after it is done, something like constructor/destructor???
	#del m  #would this work? STILL PRINTS BOTH!!!

	#m = Transmitter(N, B=2, verbose=True)
	##iterate here???
	#while (m.TDMA_MODE != -1):
		#time.sleep(.5)
	
	#tot = m.TOTAL_TRANSMISSIONS
	#print 'TDMA MODE is ', m.TDMA_MODE, '. Total for this experiment is ', tot

	#m.compute_matrices()
	#m.tdma_stage()
	#m.main_loop()
	#time.sleep(1)
	#m.send()
