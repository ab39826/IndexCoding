#!/usr/bin/python

# python stuff
import time
import sys
import numpy as np

# index coding stuff
from Symbol import Symbol
from alignment import alignment, nullvec
from bs_index_coding import compute_interferers, transmit_messages, bs_decode_messages
from multirandperm import pairingperm

# tos stuff, all needed?
from TxSerialMsg import *
from SymMsg import *
from T2HMsg import *
from AckMsg import *
from tinyos.message import MoteIF

class Transmitter:
	def __init__(self, N, B=1, verbose=True, dest=False): #is pieces 1 here?
		self.verbose = verbose
		self.prevtime = time.time()
		self.N = N
		#self.A = make_A_matrix(self.N)
		self.counter = 0;
		self.num_transmissions = 0;
		self.current_row = 0;

		## Set up link to tos mote
		self.mif = MoteIF.MoteIF()
		self.source = self.mif.addSource("sf@localhost:9002")
		#TxSerialMsg.py is be generated by MIG class
		self.mif.addListener(self, TxSerialMsg)

		# generate random messages
		self.W = np.random.randint(0,2**16, (N,B)) # each message is an array of B uint16s
		#print 'W is :'
		#print self.W
		# store final received messages. goal is to "de-NaN" by the end
		self.final_messages = np.nan*np.zeros((N, B))
		#not actually messages but indicator if all the pieces for the node have been received
		self.final_messages = np.nan*np.zeros((N, 1))
		# keep track of all transmitted and received messages/symbols
		self.tx_symbols = np.array([]) # [1 -by- # of transmissions]

		# keep track of number of transmissions
		self.TOTAL_TRANSMISSIONS = 0
		# for TDMA round also?
		self.TDMA_TRANSMISSIONS = 0

		# antidote matrix A
		#self.A = np.diag(self.W.reshape(-1)) # receiver (row) i has access to the message it plans to send
		#rewrite so not dependent on W
		self.A = np.eye(N)
		
		# Receiver i wants message dest[i]
		# e.g. dest = [1, 0] means R0 wants W[1] and R1 wants W[0]
		if dest == False:
			self.dest = pairingperm(N)
			if self.verbose:
				print 'Message destinations chosen by pairing'
				print 'dest:', self.dest
		else:
			self.dest = dest
		mat_dest = (np.arange(self.N), np.array(self.dest))
		signal_space = np.zeros((self.N,self.N))>0
		signal_space[mat_dest] = True;
		self.I = compute_interferers(self.A, signal_space)
		self.J = self.I.astype(float)
		self.J[mat_dest] = -1
		self.map = np.arange(self.N)
		print 'size of I is ', np.size(self.I)
	
		if self.verbose:
			print 'Interferer matrix is:'
			print self.J

		#send the first tdma packet?
		self.TDMA_MODE = 1;
		#self.tm = 0; #needed?
		self.TDleft = np.arange(self.N, dtype=np.uint8)
		self.ackList = np.nan*self.TDleft
		#self.ileft = 0; 
		#transmit the first message
		Transmitter.tdma_stage(self)
		self.ileft = 1

	def tdma_stage(self):
		smsg = TxSerialMsg()
		#self.TDMA_MODE = 1;
		#self.TDleft = np.arange(self.N, dtype=np.uint8)
		#self.ackList = np.nan*self.TDleft
		#test to send something
		#smsg.set_messageid(1)
		#self.mif.sendMsg(self.source, 0xFFFF, smsg.get_amType(), 0, smsg)
		#tm = 0; #move up
		#set packet number
		#while np.any(np.isnan(self.ackList)): #change while to if and call at the end of receive loop?
			#tm = tm + 1
			#for i in self.TDleft:
				#mote doesnt see any of these??
		self.TDMA_TRANSMISSIONS += 1
		#smsg.set_crow(255) #something to signal tdma mode, still necessary?
		smsg.set_messageid(int(self.ileft)) 
		#for(j=len(self.dest[i])) eventually loop through J matrix columns that are -1
		smsg.set_data(self.W[self.dest[self.ileft]])
		#also send own message w[i] for comparison????, set to V_row?
		#print 'TDMA V Row ', self.W
		#smsg.set_V_row(self.W[self.ileft])
		smsg.set_current_transmission(self.TDMA_TRANSMISSIONS)
		self.mif.sendMsg(self.source, 0xFFFF, smsg.get_amType(), 0, smsg)
		print'TDMA TRANSMISSION ', self.TDMA_TRANSMISSIONS, ': Motes remaining: ', self.TDleft
			##call tinyos receive thread instead?
			#rmsg = AckMsg(msg.dataGet())
			##check for acks, remove nodes with ack type 1 from TDMAleft, record transmissions?
			#newAck = rmsg.get_ACKs()
			#acklist[newAck==1] = 1
		#print 'Finished TDMA after ', tm, ' transmissions.' #use tm or get_transmission from receive function? will it make a difference?

	def index_stage(self):
		smsgx = TxSerialMsg()
		smsgx.set_messageid(255)  #now something to represent index coding, 255?
		#print 'V is ', self.V
		#print 'm_i is ', self.m_i
		#print 'row of V is type ', type(self.V[self.m_i])
		#print 'converted row of V is type ', type(np.asarray(self.V[self.m_i], dtype=np.float64))
		#print 'an element of V is ', type(self.V[2,3])
		#print 'the dot is fine, type ', type(np.dot(self.V[self.m_i,:],self.W,))
		#PIECES HERE?
		smsgx.set_data(np.dot(self.V[self.m_i,:],self.W,))					
		##also send own message w[i] for comparison????
		#says its not a float????!! ndarray works fine in Decoded.py
		#print 'expected size of V_row is', smsgx.numElements_V_row(0)
		#smsgx.set_V_row(np.asarray(self.V[self.m_i], dtype=np.float32))
		smsgx.set_V_row(np.array([1, 2, 3.5, 4.2, 5, 6, 7, 8], dtype=np.float64))
		#print 'sending row m of V: ', self.V[self.m_i]
		smsgx.set_V_row(self.V[self.m_i])
		smsgx.set_current_transmission(self.TOTAL_TRANSMISSIONS)
		self.mif.sendMsg(self.source, 0xFFFF, smsgx.get_amType(), 0, smsgx)

	
	def receive(self,src,msg):  #make this main_loop and have it call tdma_stage and index_stage?, or set different modes in the other functions
		#tdma tx, index tx, or completed depending on mode
		if self.TDMA_MODE==1:
			#print 'ileft is ', self.ileft, ', size if tdleft is  ', np.size(self.TDleft)
			if self.ileft == np.size(self.TDleft):
				self.ileft = 0; #only update acklist here?
				#not completely correct?? what if size changes inbetween?
				#only update tdleft here?
				self.TDleft = np.nonzero(np.isnan(self.ackList.reshape(-1)))[0] 				
			print 'RECEIVE FUNCTION (TDMA)'
			rmsg = T2HMsg(msg.dataGet())
			#check for acks, remove nodes with ack type 1 from TDMAleft, record transmissions?
			newAck = rmsg.get_ACKs()
			print 'Acks for transmission number ', rmsg.get_transmission(), ': ', newAck #first one is 8? 2? garbage value
			#print 'Element equal to 1: ', np.array(newAck)==1 #want this to be an array of logicals
			self.ackList[np.array(newAck)==1] = 1
			#self.TDleft = np.nonzero(np.isnan(self.ackList.reshape(-1)))[0]
			#call tdma_stage(self) at end if np.any(np.isnan(self.ackList))
			if np.any(np.isnan(self.ackList)):
				#self.tm = self.tm + 1
				#for i in self.TDleft:
				Transmitter.tdma_stage(self)
				self.ileft += 1
				
			else:
				print 'Finished TDMA after ', self.TDMA_TRANSMISSIONS, ' transmissions.' #use get_transmission from receive function? will it make a difference?
				self.TDMA_MODE = 0; #initialize and proceed to index coding mode
				self.m_i = 0;
				self.i = 1;
				self.m = 0;
				self.unsolved = self.map > -50; #array of true the size of self.map 
				self.rx_symbols = 0;
				self.eps_vec = 0*np.ones(self.N)
				R = transmit_messages(1, self.eps_vec[self.map])
				self.rx_symbols = R
				#send the first index message here? call compute_matrices for the first time here?
				#handle first case here?
	
		elif self.TDMA_MODE == 0:
			print 'RECEIVE FUNCTION (INDEX CODING)'
			#get next set of messages
			#if self.m_i == m or self.i == 0:
			#update once the round has been completed
			#print 'early unsolved are ', self.unsolved #not updating properly
			if self.m_i == self.m or np.any(~self.unsolved):
				self.m_i = 0;
				#Transmitter.compute_matrices(self)
				self.map = np.nonzero(np.isnan(self.final_messages.reshape(-1)))[0]
				self.rx_symbols = self.rx_symbols[self.unsolved, :]
				self.J = self.J[self.unsolved, :]
				self.I = self.I[self.unsolved, :]
				self.A = self.A[self.unsolved, :]
				Transmitter.compute_matrices(self)			
			#case for first transmission, must compute matrices first?
			if self.TOTAL_TRANSMISSIONS == 0:
				self.TOTAL_TRANSMISSIONS = 1
				Transmitter.index_stage(self)
				self.m_i += 1
				self.i += 1
				return
			
			rmsgx = T2HMsg(msg.dataGet())
			#check for acks, remove nodes with ack type 1 from TDMAleft, record transmissions?
			newAck = np.array(rmsgx.get_ACKs())
			#print 'Acks for transmission number ', rmsgx.get_transmission(), ': ', newAck
			#RECEIVE FROM TARGET HERE
					##INTERPRET ACKS HERE
					#m_i += 1
					#i += 1
					#self.final_messages = final_messages
			# update data structures, and now final messages and unsolved
			#self.unsolved = np.array(newAck)!=1
			print 'RX ACKS: ' , newAck
			print 'map: ', self.map
			self.unsolved = newAck[self.map] != 1
			#self.final_messages2 = self.final_messages
			self.final_messages[newAck==1] = 1
			#self.unsolved = self.final_messages != 1
			#print 'Rx DEST ', self.dest
			#print 'Rx NEW UNSOLVED: ', self.unsolved
			print 'Rx NEW finalmessages: '
			print self.final_messages
			
			#send to all motes at end if np.any(np.isnan(self.final_messages)) ?? 
			if np.any(np.isnan(self.final_messages)):
				self.tx_symbols = np.append(self.tx_symbols, Symbol(self.V[self.m_i,:], self.W, self.map))
				R = transmit_messages(1, self.eps_vec[self.map])
				if self.i == 1:
					self.rx_symbols = R
				else:
					self.rx_symbols = np.bmat([self.rx_symbols, R])
				if self.verbose:
					print 'Transmission ', self.m_i+1, '/', self.m  #m_i+1 or now just m_i ???
					print self.rx_symbols.astype(int)
				self.TOTAL_TRANSMISSIONS += 1
				Transmitter.index_stage(self)
				self.m_i += 1
				self.i += 1
				#Transmitter.compute_matrices(self)
				#print 'late unsolved is ', self.unsolved
			else:
				if self.verbose:
					print 'Total number of transmissions: ', self.TOTAL_TRANSMISSIONS
				self.TDMA_MODE = -1
				return self.TOTAL_TRANSMISSIONS #also exit program?
		else:
			#completed, print this indefinitely
			print 'INDEX CODING COMPLETE: Total number of transmissions: ', self.TOTAL_TRANSMISSIONS
			return self.TOTAL_TRANSMISSIONS
			#iterate??
		

	def compute_matrices(self): #change to compute_matrixes
		#self.TDMA_MODE = 0;
		#eps_vec = .5*np.ones(self.N)
		self.eps_vec = 0*np.ones(self.N)
		#self.i = 1
		#while np.any(np.isnan(self.final_messages)):
		Kprime = len(self.map);
		if self.verbose:
			print 'Remaining ', Kprime, ' nodes are: '
			print self.map
			## special case for one remaining node
		if Kprime == 1:
			self.TOTAL_TRANSMISSIONS += 1
			while not transmit_messages(1, self.eps_vec[self.map]):
				self.TOTAL_TRANSMISSIONS += 1
			self.final_messages[self.map] = self.W[self.map]
		else:
			## Generate next m transmissions
			(self.V, U) = alignment('mixed', self.J, 1e-4, 100, False)
			#try changing it here??
			self.V = np.asarray(self.V)
			print 'new V is '
			print self.V
			#print 'type of new V is ', type(self.V)
			#print 'type of an element of new V is ', type(self.V[0,0])
			self.m = np.shape(self.V)[0]
			if self.verbose:
				print 'Minimum rank is ', self.m
			# generate next symbol based on current V
			L = len(self.tx_symbols);
			if self.i == 1:
				L = 0
			self.unsolved = np.ones(Kprime) > 0
				#m_i = 0
				
				#while np.all(self.unsolved) and m_i < m:
					#self.tx_symbols = np.append(self.tx_symbols, Symbol(V[m_i,:], self.W, self.map))
					#R = transmit_messages(1, eps_vec[self.map])
					#if self.i == 1:
						#self.rx_symbols = R
					#else:
						#self.rx_symbols = np.bmat([self.rx_symbols, R])
					#if self.verbose:
						#print 'Transmission ', m_i+1, '/', m
						#print self.rx_symbols.astype(int)
					#self.TOTAL_TRANSMISSIONS += 1
					## solve for messages if possible
					#(self.unsolved, final_messages) = bs_decode_messages(self.dest, Kprime, self.map,
							#self.rx_symbols, self.tx_symbols, self.A, self.I, self.J, self.W, self.final_messages, self.verbose)
					#time.sleep(.2)
					#print 'UNSOLVED: ', self.unsolved
					#print 'MAP: ' , self.map
					#SEND TO TARGET HERE, rewrite these lines
					#smsg.set_crow
					
					#smsgx.set_messageid(255)  #now something to represent index coding, 255?
					#smsgx.set_data(np.dot(V[m_i],self.W,))					
					###also send own message w[i] for comparison????
					#smsgx.set_V_row(V[m_i]) 
					#smsgx.set_current_transmission(self.TOTAL_TRANSMISSIONS)
					#self.mif.sendMsg(self.source, 0xFFFF, smsgx.get_amType(), 0, smsgx)
					##time.sleep(1) #.125 too fast?
	
					#INTERPRET ACKS IN RECEIVE FUNCTION
					#m_i += 1
					#i += 1
					#self.final_messages = final_messages #still need final messages??
				## update data structures
				#self.map = np.nonzero(np.isnan(self.final_messages.reshape(-1)))[0]
				#self.rx_symbols = self.rx_symbols[self.unsolved, :]
				#self.J = self.J[self.unsolved, :]
				#self.I = self.I[self.unsolved, :]
				#self.A = self.A[self.unsolved, :]
		#if self.verbose:
			#print 'Total number of transmissions: ', self.TOTAL_TRANSMISSIONS
		#return self.TOTAL_TRANSMISSIONS


	# Called by the MoteIF's receive thread when a new message
	# is received
	#def receive(self, src, msg):
		#time.sleep(1)
		#m = DecodedMsg(msg.dataGet())
		#self.counter = m.get_counter()
		#timeformat = '%Y/%d/%m %H:%M:%S'
		#print 'Received message %s: counter: %d' % (time.strftime(timeformat), self.counter)
		#print ' current row: ', m.get_current_row()
		#print ' true current row: ', self.current_row
		#z = np.array(m.get_V_row())
		#z = z[0:self.current_row+1]
		#print z
		#V = self.A[:m.get_current_row()+1]
		##U, S, W = np.linalg.svd(V.T)
		##print S
		#Vnull = V[ :, [1,3,5,7] ]
		##U,S,V = np.linalg.svd(Vnull.T)
		##print S
		#print np.matrix(Vnull).T*np.matrix(z).T
		
		##U, s, W = np.linalg.svd(Vnull.T)
		##print W.T

		##print self.A[m.get_current_row()][:]
		##print m.get_current_row()
		##print S
		##V_null = self.A[0:self.current_row+1,[1,3, 9, 14]]
		##U, S, W = np.linalg.svd(V_null)
		##print S
		##if m.get_perform_svd() == self.N:
			###print '  svd received:'
			##Svals = m.get_W()
			##print 'Rx svd: ', Svals
			##U,S,V = np.linalg.svd(self.A)
			###S = [s**2 for s in S]
			###print '  svd check:'
			##print 'PC svd: ', S
			##self.perform_svd = 0
			##self.A = make_A_matrix(self.N)
			##print 'MSE: ', np.linalg.norm(np.array(S)-np.array(Svals),2)
			##proctime = time.time() - self.prevtime
			##print 'Elapsed time: %f seconds' % proctime
		##else:
			##self.prevtime = time.time()
			##self.perform_svd += 1
		#self.counter += 1
		#self.current_row = (self.current_row + 1) % self.N
		##if self.current_row == 0:
			##self.A = make_A_matrix(self.N)
		#self.send()

	#uncomment this?? is it still useful?
	#def send(self,m_i):
		#smsg = TxSerialMsg()
		##smsg.set_counter(self.counter)
		#smsg.set_crow(self.current_row)
		##smsg.set_V_row(self.A[self.current_row])
		#smsg.set_V_row(V[m_i,:])
		#smsg.set_data(self.tx_symbols[:,m_i])
		#Symbol(V[self.current_row,:], self.W, self.map)	  
		#smsg.set_data(self.sym[self.current_row])
		#self.mif.sendMsg(self.source, 0xFFFF, smsg.get_amType(), 0, smsg)
		#TDMA round, send message j to mote self.dest[j]


#def make_A_matrix(N):
	#A = np.random.randn(N,N)
	#B = np.matrix(np.random.randn(4,4))
	#U, s, W = np.linalg.svd(B)
	#s[-1] = 0
	#B = np.array(U*np.diag(s)*W)
#
#	
	#A[0:4,1] = B[:,0]
	#A[0:4,3] = B[:,1]
	#A[0:4,5] = B[:,2]
	#A[0:4,7] = B[:,0]
	##print A
#
#
#
	#return A

if __name__ == "__main__":
	print "Running"
	np.set_printoptions(precision=3)
	np.set_printoptions(suppress=True)

	if len(sys.argv) > 1:
		N = int(sys.argv[1])
	else:
		N  = 6
	m = Transmitter(N, B=2, verbose=True)
	#m.compute_matrices()
	#m.tdma_stage()
	#m.main_loop()
	#time.sleep(1)
	#m.send()
