#!/usr/bin/python

import time
import numpy as np
import sys

#tos stuff
from DecodedMsg import *
from tinyos.message import MoteIF

class MyClass:
	def __init__(self,N):
		self.prevtime = time.time()
		self.N = N
		self.A = make_A_matrix(self.N)
		self.current_row = 0;
		# Create a MoteIF
		self.mif = MoteIF.MoteIF()
		# Attach a source to it
		self.source = self.mif.addSource("sf@localhost:9002")

		# SomeMessageClass.py would be generated by MIG
		self.mif.addListener(self, DecodedMsg)

	def send(self):
		smsg = DecodedMsg()
		#this line here needs to be changed to just be random coefficients.
		blah = np.random.randn(1,self.N)
		smsg.set_V_coeff(blah[0,:])
		
		
		#smsg.set_V_coeff(self.A[self.current_row])

		smsg.set_crow(self.current_row)
		smsg.set_data([1])
		self.mif.sendMsg(self.source, 0xFFFF, smsg.get_amType(), 0, smsg)

	# Called by the MoteIF's receive thread when a new message
	# is received
	def receive(self, src, msg):
		time.sleep(1)
		m = DecodedMsg(msg.dataGet())
		timeformat = '%Y/%d/%m %H:%M:%S'
		print 'Received message %s:' % time.strftime(timeformat)
		print ' true current row: ', self.current_row


		## get received data from mote
		rec_row = m.get_crow()
		print rec_row

		x_mote = np.array(m.get_V_coeff())
		#x_mote = x_mote[0:self.current_row+1]


		print 'mote result: ', x_mote

		

		## check functionality in python
		V = self.A[:self.current_row+1]
		#print 'A', self.A
		#print 'V', V
		#U, S, W = np.linalg.svd(V.T)
		#print S
		Vnull = V[ :, [1,3,5,7] ]
		z = nullvec(Vnull.T)
		#print z
		ant_vec = np.mat('[0; 0; :1; 0; 1; 0; 1; 0]')

		Vant = V*ant_vec
		
		if len(z)>0:
			print 'antidoteresult: ',z.T*Vant
		else:
			print 'antidoteresult: ',[]

		if len(z)>0:
			#x_python = np.dot(z.T, V[:,0])
			#print x_python
			#print np.shape(z), np.shape(Vnull)
			#print np.matrix(Vnull).T*np.matrix(z)
			nulldata= z.T*np.ones((self.current_row+1,1))
			antdata = z.T*Vant
			finalresult = nulldata - antdata
			maindimension = V[:,[0]]
			xdot = z.T*maindimension
			finalresult = (finalresult/xdot)
			print 'final result: ',finalresult

			
		else:
			print []
		#U,S,V = np.linalg.svd(Vnull.T)
		#print S

		
		#U, s, W = np.linalg.svd(Vnull.T)
		#print W.T

		#print self.A[m.get_current_row()][:]
		#print m.get_current_row()
		#print S
		#V_null = self.A[0:self.current_row+1,[1,3, 9, 14]]
		#U, S, W = np.linalg.svd(V_null)
		#print S
		#if m.get_perform_svd() == self.N:
			##print '  svd received:'
			#Svals = m.get_W()
			#print 'Rx svd: ', Svals
			#U,S,V = np.linalg.svd(self.A)
			##S = [s**2 for s in S]
			##print '  svd check:'
			#print 'PC svd: ', S
			#self.perform_svd = 0
			#self.A = make_A_matrix(self.N)
			#print 'MSE: ', np.linalg.norm(np.array(S)-np.array(Svals),2)
			#proctime = time.time() - self.prevtime
			#print 'Elapsed time: %f seconds' % proctime
		#else:
			#self.prevtime = time.time()
			#self.perform_svd += 1
		self.current_row = (self.current_row + 1) % self.N
		#if self.current_row == 0:
			#self.A = make_A_matrix(self.N)
		self.send()


def make_A_matrix(N):
	A = np.random.randn(N,N)
	B = np.matrix(np.random.randn(4,4))
	U, s, W = np.linalg.svd(B)
	s[-1] = 0
	B = np.array(U*np.diag(s)*W)

	
	A[0:4,1] = B[:,0]
	A[0:4,3] = B[:,1]
	A[0:4,5] = B[:,2]
	A[0:4,7] = B[:,0]
	print A

	return A

def nullvec(X, tol=1e-5):
	if np.shape(X)[0] == 0:
		V = np.eye(np.shape(X)[1])
	else:
		(U, s, Vt) = np.linalg.svd(X)
		V = Vt.T
	if np.shape(X)[1] > np.shape(X)[0]:
		z = V[:, -1]
	else:
		s = s < tol
		if np.any(s):
			z = V[:, s]
		else:
			z = []
	return np.matrix(np.array(z).reshape(-1, 1))

if __name__ == "__main__":
	print "Running"
	np.set_printoptions(precision=3)
	np.set_printoptions(suppress=True)

	if len(sys.argv) > 1:
		N = int(sys.argv[1])
	else:
		N  = 6
	m = MyClass(N)
	time.sleep(1)
	m.send()
